import numpy as np
import shem.geometry

def superposition(N, function_dict, theta, phi):
    '''
    Accepts the parameters:
        N - Int. The number of rays to sample from the distribution.
        theta - Float.
        phi - Float.
        function_dict - Dictionary of numbers indexed by functions defined in shem.source_functions.
    Returns:
        rays - An N x 3 NumPy array of direction vectors.
    '''
    
    rays = np.zeros([N, 3], dtype=np.float32)

    # Determine how many rays should be sampled from each distribution.
    strengths = np.array([d['strength'] for d in list(function_dict.values())])
    rel_strengths = strengths / np.sum(strengths)
    choice_criteria = np.cumsum(rel_strengths)
    choice_criteria = np.insert(choice_criteria, 0, 0)
    
    # Choose each function with a weighting taken from rel_strengths.
    function_choice = np.random.rand(N)
    function_count = np.empty(len(function_dict), dtype=np.dtype('int'))
    for f, _ in enumerate(function_dict):
        # Count the number of rays to be generated by each function.
        function_count[f] = np.count_nonzero(np.logical_and(function_choice >= choice_criteria[f], function_choice < choice_criteria[f+1]))
    # Determine the range of indices in rays to be assigned.
    function_indices = np.cumsum(function_count)
    function_indices = np.insert(function_indices, 0, 0)
    for f, func in enumerate(function_dict):
        # Use each source function to generate the required number of rays.
        rays[function_indices[f]:function_indices[f+1]] = func(function_count[f], theta, phi, function_dict[func])

    # Normalise the direction vectors.
    # Arguably the functions should do this but this is convenient.
    rays /= np.linalg.norm(rays, axis=-1).reshape(-1, 1)
    return rays

def delta(N, theta, phi, kwargs):
    '''
    Accepts the parameters:
        N - Int. Number of rays to generate,
        theta - Float.
        phi - Float.
    Returns:
        A length 3 NumPy array pointing in the (theta, phi) direction.
    '''
    a = np.full([N, 3], [1.0, theta, phi])
    # We need the -ve sign since the direction goes from source to mesh/origin.
    return -shem.geometry.polar2cart(a, radians=True)

# Identical function for testing purposes.
def uniform_cone(N, theta_, phi_, kwargs):
    delta_theta = kwargs['delta_theta']
    delta_phi = kwargs['delta_phi']
    
    theta = theta_ + delta_theta*(np.random.rand(N)-0.5)
    phi = phi_ + delta_theta*(np.random.rand(N)-0.5)
    
    a = np.array([
        np.ones(N),
        theta,
        phi
    ]).T
    # We need the -ve sign since the direction goes from source to mesh/origin.
    return -shem.geometry.polar2cart(a, radians=True)

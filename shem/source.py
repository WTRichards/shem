import os, sys
import numpy as np
import cupy as cp

from shem.definitions import *
import shem.geometry

# Point source. Points straight to displacement.
def delta(use_func, rays, displacement, source, source_radius, params):
    xp = cp.get_array_module(use_func, rays, displacement, source)
    a = rays[0]
    b = rays[1]

    x = use_func[0]
    y = use_func[1]
    n = use_func[0].size

    # All in same direction
    # We need the -ve sign since the direction goes from source to mesh/origin.
    a[use_func] = -shem.geometry.vector_normalise(source)
    b[use_func] = displacement[x, y] + source
    
    return

# Point source. Uniform cone.
def uniform_cone(use_func, rays, displacement, source, source_radius, params):
    xp = cp.get_array_module(use_func, rays, displacement, source)
    a = rays[0]
    b = rays[1]

    x = use_func[0]
    y = use_func[1]
    n = use_func[0].size
    
    source_polar = shem.geometry.cart2polar(source, radians=True)
    
    # Randomised values of theta and phi
    theta = source_polar[..., THETA] + params.delta_theta*(xp.random.rand(n)-0.5)
    phi   = source_polar[..., PHI]   + params.delta_phi*(xp.random.rand(n)-0.5)

    # Randomised direction vectors in polar coordinates
    a_polar = xp.array([
        xp.ones(n),
        theta,
        phi
    ]).T

    a[use_func] = -shem.geometry.polar2cart(a_polar, radians=True)
    b[use_func] = displacement[x, y] + source

    return


SOURCE_FUNCTIONS = {
        'delta'        : delta,
        'uniform_cone' : uniform_cone,
}


def superposition(rays, displacement, source, source_radius, function_):
    xp = cp.get_array_module(displacement, source)
    
    x_dim = rays.shape[1]
    y_dim = rays.shape[2]
    nparallel = rays.shape[3]

    function = dict(((SOURCE_FUNCTIONS[k], v) for k, v in function_.items()))

    # Determine what proportion of the rays should be sampled from each distribution.
    strengths = xp.array([params.strength for params in function.values()])
    
    rel_strengths = strengths / xp.sum(strengths)
    choice_criteria = xp.empty(strengths.size + 1)
    choice_criteria[0]  = 0
    choice_criteria[1:] = xp.cumsum(rel_strengths)
    
    # Choose each function with a weighting taken from rel_strengths.
    function_choice = xp.random.rand(x_dim, y_dim, nparallel)

    # WARNING: This code uses pass-by-reference rather than pass-by-value because it is more efficient and simple.
    # That's usually good but it can make it easier to make mistakes.
    # Functional programming is usually better to maintain and unit test (IMO).
    for f, func in enumerate(function):
        params = function[func]
        # Indices of elements generated by the specified function
        use_func = xp.nonzero(xp.logical_and(function_choice >= choice_criteria[f], function_choice < choice_criteria[f+1]))
        # Pass by reference and assign to rays the appropriate values
        func(use_func, rays, displacement, source, source_radius, params)

    rays[0] = shem.geometry.vector_normalise(rays[0])

    return rays
